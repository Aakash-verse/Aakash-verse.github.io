<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aakash Kumar — Header Graph</title>
  <style>
    :root{
      --electric-1: #00d4ff; /* bright electric blue */
      --electric-2: #00a8ff; /* deeper tone */
      --bg: #00a8ff; /* electric blue background for header */
      --glass: rgba(255,255,255,0.02);
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Arial,sans-serif}

    /* header that contains the canvas background */
    .hero-wrap{
      position:relative;
      min-height:240px;
      display:flex;
      align-items:center;
      justify-content:center;
      color: white;
      overflow:hidden;
      padding:2.25rem 1rem;
      box-sizing:border-box;
    }

    /* The canvas sits behind the content */
    canvas.graph-canvas{
      position:absolute; inset:0; width:100%; height:100%; display:block; z-index:0;
    }

    /* content (name + subtitle) sits above canvas */
    .hero-content{
      position:relative; z-index:2; text-align:center; max-width:1200px; width:100%;
      pointer-events:none; /* make mouse interact with canvas beneath */
    }
    .hero-content h1{margin:0; font-size:2.1rem; letter-spacing:0.6px; font-weight:700; color: white}
    .hero-content p{margin:0.5rem 0 0; color: rgba(255,255,255,0.85)}

    /* small accessibility hint: if user wants to interact with links inside header, give them pointer events back */
    .hero-content a{pointer-events:auto}

    /* subtle vignette over canvas for contrast */
    .vignette{ position:absolute; inset:0; pointer-events:none; z-index:1; background:radial-gradient(ellipse at center, rgba(0,0,0,0) 30%, rgba(0,0,0,0.18) 100%); }

    /* fallbacks & reduced motion */
    @media (prefers-reduced-motion: reduce){
      canvas.graph-canvas{ animation: none !important }
    }

    /* small screens */
    @media (max-width:480px){ .hero-content h1{font-size:1.4rem} }
  </style>
</head>
<body>

  <header class="hero-wrap" role="banner" aria-label="Header with animated graph background">
    <canvas class="graph-canvas" id="graphCanvas" aria-hidden="true"></canvas>

    <div class="vignette" aria-hidden="true"></div>

    <div class="hero-content">
      <h1>Aakash Kumar</h1>
      <p>PhD Student — Theoretical Machine Learning · Physics</p>
    </div>
  </header>

  <script>
  // Animated node-line graph background — electric blue theme
  // Features:
  // - moving nodes with spring-to-origin for stability
  // - lines drawn between nearby nodes with alpha scaled by distance
  // - nodes react to pointer by repelling and lighting up
  // - respects devicePixelRatio and prefers-reduced-motion

  (function(){
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    // Config — tweak these values to change behavior
    const CONFIG = {
      nodeCountDensity: 0.00025,   // much sparser (fewer nodes)   // nodes per px^2 (scaled by area)
      nodeRadius: 2.2,            // base radius in CSS pixels
      maxLinkDistance: 140,       // max px distance to draw link
      lineWidth: 0.9,
      speed: 0.5,                 // global animation speed multiplier
      repulseRadius: 120,         // pointer repulsion radius
      pointerForce: 0.75,         // how strongly pointer repels nodes
      originAttraction: 0.02,     // spring strength to original position
      friction: 0.92,             // velocity damping
      color1: '#ffffff',         // nodes/lines white         // electric bright
      color2: '#ffffff'          // deeper
    };

    // Respect reduced motion preference
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReduced){
      CONFIG.speed = 0; // freeze animation
    }

    let width = 0, height = 0, nodes = [];
    const pointer = { x: null, y: null, down:false };

    function resize(){
      const rect = canvas.getBoundingClientRect();
      width = Math.max(100, Math.floor(rect.width));
      height = Math.max(80, Math.floor(rect.height));
      canvas.width = Math.floor(width * DPR);
      canvas.height = Math.floor(height * DPR);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // create or prune nodes based on area
      const area = width * height;
      const desired = Math.max(12, Math.round(area * CONFIG.nodeCountDensity));
      if (nodes.length < desired) {
        const toAdd = desired - nodes.length;
        for (let i=0;i<toAdd;i++) nodes.push(createNode());
      } else if (nodes.length > desired) {
        nodes.length = desired;
      }

      // Reassign origin positions to fit new size
      nodes.forEach(n => {
        n.ox = n.oxNormalized * width;
        n.oy = n.oyNormalized * height;
        // if outside new bounds, clamp
        n.x = Math.max(0, Math.min(width, n.x));
        n.y = Math.max(0, Math.min(height, n.y));
      });
    }

    function createNode(){
      // spread origin positions in a subtle grid with jitter
      const ox = Math.random();
      const oy = Math.random();
      const node = {
        oxNormalized: ox, // in [0,1] to allow resize recompute
        oyNormalized: oy,
        ox: ox * width,
        oy: oy * height,
        x: ox * width + (Math.random()-0.5)*30,
        y: oy * height + (Math.random()-0.5)*30,
        vx: (Math.random()-0.5) * 0.6,
        vy: (Math.random()-0.5) * 0.6,
        r: CONFIG.nodeRadius,
        pulse: Math.random()*Math.PI*2,
        hueShift: Math.random()*40 - 20 // slight variance
      };
      return node;
    }

    // Utility: linear interpolation
    function lerp(a,b,t){return a+(b-a)*t}

    // Animation loop
    let last = performance.now();
    function frame(now){
      const dt = Math.min(40, now - last) / 16.666; // ~60fps baseline
      last = now;
      update(dt * CONFIG.speed);
      render();
      if (CONFIG.speed !== 0) requestAnimationFrame(frame);
    }

    function update(elapsed){
      // elapsed may be 0 if reduced motion
      nodes.forEach(node => {
        // attraction to origin (spring)
        const dx0 = node.ox - node.x;
        const dy0 = node.oy - node.y;
        node.vx += dx0 * CONFIG.originAttraction * elapsed;
        node.vy += dy0 * CONFIG.originAttraction * elapsed;

        // slight procedural motion (per-node subtle wandering)
        node.pulse += 0.01 * elapsed;
        node.vx += Math.cos(node.pulse) * 0.003 * elapsed;
        node.vy += Math.sin(node.pulse) * 0.003 * elapsed;

        // pointer interaction: repulse if within radius
        if (pointer.x !== null){
          const dx = node.x - pointer.x;
          const dy = node.y - pointer.y;
          const dist = Math.hypot(dx,dy);
          if (dist < CONFIG.repulseRadius){
            // normalized force away from pointer
            const force = (1 - (dist / CONFIG.repulseRadius)) * CONFIG.pointerForce * (pointer.down ? 2.2 : 1.0);
            const nx = dx/dist || (Math.random()-0.5);
            const ny = dy/dist || (Math.random()-0.5);
            node.vx += nx * force * elapsed * 1.2;
            node.vy += ny * force * elapsed * 1.2;
          }
        }

        // velocity damping
        node.vx *= CONFIG.friction;
        node.vy *= CONFIG.friction;

        // step
        node.x += node.vx * elapsed;
        node.y += node.vy * elapsed;

        // small bounds clamp with wrap-around-like pull
        if (node.x < -20) node.x = width + 20;
        if (node.x > width + 20) node.x = -20;
        if (node.y < -20) node.y = height + 20;
        if (node.y > height + 20) node.y = -20;
      });
    }

    function render(){
      ctx.clearRect(0,0,width,height);

      // draw links
      ctx.lineWidth = CONFIG.lineWidth;
      ctx.lineCap = 'round';
      for (let i=0;i<nodes.length;i++){
        const a = nodes[i];
        for (let j=i+1;j<nodes.length;j++){
          const b = nodes[j];
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const d2 = dx*dx + dy*dy;
          if (d2 > CONFIG.maxLinkDistance * CONFIG.maxLinkDistance) continue;
          const d = Math.sqrt(d2);
          const t = 1 - (d / CONFIG.maxLinkDistance); // 0..1 (closer => stronger)

          // color gradient based on midpoint + pointer proximity
          const mx = (a.x + b.x) / 2;
          const my = (a.y + b.y) / 2;

          // alpha shaped by distance and by proximity to pointer (highlight)
          let alpha = Math.pow(t, 1.1) * 0.85;
          if (pointer.x !== null){
            const pd = Math.hypot(mx - pointer.x, my - pointer.y);
            if (pd < CONFIG.repulseRadius) alpha = Math.max(alpha, 0.9 * (1 - pd / CONFIG.repulseRadius));
          }

          // gradient stroke
          const grad = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
          grad.addColorStop(0, shadeColor(CONFIG.color1, a.hueShift, alpha));
          grad.addColorStop(1, shadeColor(CONFIG.color2, b.hueShift, alpha));

          ctx.strokeStyle = grad;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }

      // draw nodes
      for (let i=0;i<nodes.length;i++){
        const n = nodes[i];
        // node highlight when pointer near
        let alpha = 0.85;
        if (pointer.x !== null){
          const pd = Math.hypot(n.x - pointer.x, n.y - pointer.y);
          if (pd < CONFIG.repulseRadius) alpha = lerp(1, 0.6, pd / CONFIG.repulseRadius);
        }

        // subtle pulsing radius
        const pulse = 0.6 + Math.sin(n.pulse*1.6) * 0.3;
        const r = Math.max(0.8, n.r * pulse);

        // radial gradient fill for glow
        const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, Math.max(8, r*6));
        g.addColorStop(0, shadeColor(CONFIG.color1, n.hueShift, alpha * 0.95));
        g.addColorStop(0.6, shadeColor(CONFIG.color2, n.hueShift, alpha * 0.25));
        g.addColorStop(1, 'rgba(0,0,0,0)');

        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(n.x, n.y, Math.max(1.4, r*2.6), 0, Math.PI*2);
        ctx.fill();

        // core dot
        ctx.fillStyle = shadeColor('#ffffff', 0, alpha);
        ctx.beginPath();
        ctx.arc(n.x, n.y, Math.max(0.8, r*0.45), 0, Math.PI*2);
        ctx.fill();
      }
    }

    // small helper to apply hue shift + alpha into rgba string
    function shadeColor(hex, hueShift=0, alpha=1){
      // simple hex -> rgb
      const c = hex.replace('#','');
      const r = parseInt(c.substring(0,2),16);
      const g = parseInt(c.substring(2,4),16);
      const b = parseInt(c.substring(4,6),16);
      return `rgba(${r},${g},${b},${Math.max(0,Math.min(1,alpha))})`;
    }

    // pointer handling
    function onPointerMove(e){
      const rect = canvas.getBoundingClientRect();
      const px = (e.clientX - rect.left);
      const py = (e.clientY - rect.top);
      pointer.x = Math.max(0, Math.min(width, px));
      pointer.y = Math.max(0, Math.min(height, py));
    }
    function onPointerLeave(){ pointer.x = null; pointer.y = null; }
    function onPointerDown(){ pointer.down = true; }
    function onPointerUp(){ pointer.down = false; }

    // wire events
    canvas.addEventListener('pointermove', onPointerMove);
    canvas.addEventListener('pointerleave', onPointerLeave);
    canvas.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointerup', onPointerUp);

    // resize observer for responsive canvas
    const ro = new ResizeObserver(resize);
    ro.observe(canvas.parentElement);

    // init nodes and start
    resize();
    // initialize a few steps to settle
    for (let i=0;i<6;i++) update(1);
    if (CONFIG.speed !== 0) requestAnimationFrame(frame); else render();

    // Expose a simple API for debugging from console
    window._graphBg = { nodes, resize, config: CONFIG };

    // --- utility: clamp and lerp defined earlier (redeclare to be safe) ---
    function lerp(a,b,t){return a + (b-a)*t}

  })();
  </script>

</body>
</html>
