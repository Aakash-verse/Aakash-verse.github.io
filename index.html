<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aakash Kumar</title>
  <style>
    :root{
      --electric-1: #00d4ff; /* bright electric blue */
      --electric-2: #00a8ff; /* deeper tone */
      --bg: #00a8ff; /* electric blue background for header/footer */
      --glass: rgba(255,255,255,0.02);
      --muted: rgba(0,0,0,0.6);
      --max-width: 1100px;
    }

    /* page baseline */
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif}
    body { background: #ffffff; color: #111; }

    /* NAVBAR */
    .nav {
      width:100%;
      background: #ffffff; /* keep page white, links use theme color */
      box-shadow: 0 1px 0 rgba(0,0,0,0.04);
      position:sticky;
      top:0;
      z-index:40;
      backdrop-filter: blur(6px);
    }
    .nav-inner{
      max-width: var(--max-width);
      margin: 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:1rem;
      padding:0.55rem 1rem;
      box-sizing:border-box;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:.6rem;
      font-weight:700;
      color: var(--bg);
      text-decoration:none;
    }
    .nav-links{
      display:flex;
      gap:.75rem;
      align-items:center;
    }
    .nav-links a{
      color: var(--muted);
      text-decoration:none;
      font-size:0.95rem;
      padding:0.35rem 0.5rem;
      border-radius:6px;
    }
    .nav-links a:hover{
      color: var(--bg);
      background: rgba(0,168,255,0.06);
      text-decoration:none;
    }

    /* header that contains the canvas background — left unchanged except not overriding nav */
    .hero-wrap{
      position:relative;
      min-height:240px;
      display:flex;
      align-items:center;
      justify-content:center;
      color: white;
      overflow:hidden;
      padding:2.25rem 1rem;
      box-sizing:border-box;
      background: var(--bg); /* keep header background as it was */
    }

    /* The canvas sits behind the content */
    canvas.graph-canvas{
      position:absolute; inset:0; width:100%; height:100%; display:block; z-index:0;
    }

    /* content (name + subtitle) sits above canvas */
    .hero-content{
      position:relative; z-index:2; text-align:center; max-width:1200px; width:100%;
      pointer-events:none; /* make mouse interact with canvas beneath */
    }
    .hero-content h1{margin:0; font-size:2.1rem; letter-spacing:0.6px; font-weight:700; color: white}
    .hero-content p{margin:0.5rem 0 0; color: rgba(255,255,255,0.85)}

    /* small accessibility hint: if user wants to interact with links inside header, give them pointer events back */
    .hero-content a{pointer-events:auto}

    /* subtle vignette over canvas for contrast */
    .vignette{ position:absolute; inset:0; pointer-events:none; z-index:1; background:radial-gradient(ellipse at center, rgba(0,0,0,0) 30%, rgba(0,0,0,0.18) 100%); }


    /* MAIN content sections */
    main{
      max-width: var(--max-width);
      margin: 2rem auto;
      padding: 0 1rem;
      box-sizing: border-box;
    }

    section {
      background: #fff;
      border-radius: 10px;
      padding: 1.2rem;
      margin-bottom: 1rem;
      min-height: 120px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.03);
      display:block;
    }
    section h2{
      margin:0 0 .6rem 0;
      font-size:1.05rem;
      color: var(--bg);
      font-weight:700;
    }

    /* FOOTER: same color as header */
    footer.site-footer{
      background: var(--bg);
      color: white;
      padding: 1.25rem;
      margin-top: 2rem;
    }
    .footer-inner{
      max-width: var(--max-width);
      margin:0 auto;
      padding: 0 1rem;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:1rem;
      box-sizing:border-box;
    }
    .footer-contact{
      font-size:0.95rem;
      color: rgba(255,255,255,0.95);
    }
 .research-panel {
        display: flex;
        gap: 1.8rem;
        align-items: center;
        padding-top: 0.5rem;
    }
    .animation-container {
        flex: 1;
        min-width: 300px;
        height: 250px;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
        background-color: #0d1a26;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
    }
    .animation-container canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
    }
    .description-container {
        flex: 1.5;
        min-width: 300px;
    }
    .description-container h3 {
        margin: 0 0 0.5rem 0;
        font-weight: 600;
        font-size: 1.1rem;
        color: #1f2937;
    }
    .description-container p {
        color: #6b7280;
        line-height: 1.6;
        margin: 0;
        font-size: 0.95rem;
    }
    /* responsive tweaks */
    @media (max-width:720px){
      .nav-inner{ padding:0.6rem; }
      .nav-links{ display:flex; gap:.5rem; }
      .footer-inner{ flex-direction:column; align-items:flex-start; gap:.6rem; }
    }

    /* reduced motion fallback */
    @media (prefers-reduced-motion: reduce){
      * { transition: none !important; animation: none !important; }
    }

  </style>
</head>
<body>

  <!-- NAVBAR (added) -->
  <nav class="nav" role="navigation" aria-label="Primary">
    <div class="nav-inner">
      <a class="brand" href="#home" aria-label="Home">
        <!-- small brand mark -->
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" />
        </svg>
        Aakash Kumar
      </a>

      <div class="nav-links" role="menu" aria-hidden="false">
        <a href="#about" role="menuitem">About</a>
        <a href="#education" role="menuitem">Education</a>
        <a href="#research" role="menuitem">Research</a>
      </div>
    </div>
  </nav>

  <!-- HEADER — kept intact -->
  <header class="hero-wrap" role="banner" aria-label="Header with animated graph background">
    <canvas class="graph-canvas" id="graphCanvas" aria-hidden="true"></canvas>

    <div class="vignette" aria-hidden="true"></div>

    <div class="hero-content">
      <h1>Aakash Kumar</h1>
      <p>PhD Student — Theoretical Machine Learning · Physics</p>
    </div>
  </header>

  <!-- MAIN content: stacked sections -->
  <main role="main" aria-labelledby="mainHeading">
    <section id="about" aria-labelledby="aboutHeading">
      <h2 id="aboutHeading">About</h2>
      <p style="color: #6b7280;">
        I am a PhD student based in Nice, affiliated with CNRS, INRIA and Université Côte d’Azur.
        My supervisor is <a href="https://natema.github.io/" style="color: grey; font-weight: bold;">Prof. Emanuele Natale</a>.
        My research focuses on the theoretical aspects of machine learning, specifically tackling problems
        at the intersection of theoretical computer science and physics. Drawing on my background in Physics
        (BS–MS, IISER Kolkata), my current interests center on foundational topics, including Hopfield networks
        and brain-inspired learning dynamics, the mathematical theory of neural network pruning, and the
        analysis of neural scaling laws.
      </p>
    </section>

    <section id="education" aria-labelledby="educationHeading">
      <h2 id="educationHeading">Education</h2>

      <!-- LinkedIn-style education entry: PhD (Inria) -->
      <div style="display:flex;align-items:flex-start;gap:1rem;padding:0.8rem;border-radius:8px;margin-bottom:0.9rem;box-shadow:0 1px 0 rgba(0,0,0,0.03);">
        <!-- logo box -->
        <div style="flex:0 0 72px; display:flex;align-items:center;justify-content:center;">
          <img src="inria.png" alt="Inria logo" style="width:64px;height:64px;object-fit:contain;border-radius:6px;box-shadow:0 1px 6px rgba(0,0,0,0.06);" />
        </div>

        <!-- details -->
        <div style="flex:1;min-width:0;">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:1rem;">
            <div>
              <div style="font-weight:700;color:#111;font-size:1rem;">PhD, Theoretical Machine Learning</div>
              <div style="margin-top:4px;color:var(--muted);font-size:0.95rem;">Inria</div>
            </div>
            <div style="color:var(--muted);font-size:0.9rem;white-space:nowrap;">2025 — 2028 (expected)</div>
          </div>
          <!-- optional subtitle / location -->
          <div style="margin-top:8px;color:rgba(0,0,0,0.6);font-size:0.92rem;">
            <!-- left intentionally empty for now (e.g., supervisor, location) -->
          </div>
        </div>
      </div>

      <!-- LinkedIn-style education entry: BS-MS (IISER Kolkata) -->
      <div style="display:flex;align-items:flex-start;gap:1rem;padding:0.8rem;border-radius:8px;margin-bottom:0.9rem;box-shadow:0 1px 0 rgba(0,0,0,0.03);">
        <!-- logo box -->
        <div style="flex:0 0 72px; display:flex;align-items:center;justify-content:center;">
          <img src="iiserk.png" alt="IISER Kolkata logo" style="width:64px;height:64px;object-fit:contain;border-radius:6px;box-shadow:0 1px 6px rgba(0,0,0,0.06);" />
        </div>

        <!-- details -->
        <div style="flex:1;min-width:0;">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:1rem;">
            <div>
              <div style="font-weight:700;color:#111;font-size:1rem;">BS-MS, Physics</div>
              <div style="margin-top:4px;color:var(--muted);font-size:0.95rem;">Indian Institute of Science Education and Research, Kolkata</div>
            </div>
            <div style="color:var(--muted);font-size:0.9rem;white-space:nowrap;">2020 — 2025</div>
          </div>
          <div style="margin-top:8px;color:rgba(0,0,0,0.6);font-size:0.92rem;">
            <!-- left intentionally empty (e.g., honours, thesis) -->
          </div>
        </div>
      </div>

    </section>

    <section id="research" aria-labelledby="researchHeading">
      <h2 id="researchHeading">Research</h2>
      <!-- New Research Panel -->
      <div class="research-panel">
          <div class="animation-container">
              <canvas id="hopfieldCanvas" aria-hidden="true"></canvas>
          </div>
          <div class="description-container">
              <h3>Directed Hopfield Networks</h3>
              <p>
                Directed Hopfield networks are a variation of classic Hopfield networks where connections between neurons are not symmetric. This asymmetry prevents them from having a simple energy function, meaning they don't always settle into stable states. Instead, their dynamics can be much richer, producing cycles or even chaotic behavior.
              </p>
          </div>
      </div>
      <!-- Additional Research Panel -->
      <div class="research-panel">
          <div class="animation-container">
              <canvas id="lotteryCanvas" aria-hidden="true"></canvas>
          </div>
          <div class="description-container">
              <h3>Strong Lottery Ticket Hypothesis</h3>
              <p>
                The Strong Lottery Ticket Hypothesis suggests that within a randomly initialized neural network, there exist subnetworks—referred to as "winning tickets"—that can achieve performance comparable to the full network when trained from the same initialization. This implies that effective network pruning can uncover sparse architectures that maintain high accuracy without requiring retraining from scratch.
              </p>
          </div>
      </div>
    </section>
  </main>

  <!-- FOOTER (same color as header) -->
  <footer class="site-footer" role="contentinfo" aria-label="Footer with contact">
    <div class="footer-inner">
      <div class="footer-contact">
        <!-- contact info left intentionally empty -->
      </div>
      <div aria-hidden="true" style="opacity:0.9;">&copy; <!-- year left empty --></div>
    </div>
  </footer>

  <!-- Original canvas script left unchanged (except kept in this file) -->
  <script>
  // Animated node-line graph background — electric blue theme
  // Features:
  // - moving nodes with spring-to-origin for stability
  // - lines drawn between nearby nodes with alpha scaled by distance
  // - nodes react to pointer by repelling and lighting up
  // - respects devicePixelRatio and prefers-reduced-motion

  (function(){
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    // Config — tweak these values to change behavior
    const CONFIG = {
      nodeCountDensity: 0.00025,   // much sparser (fewer nodes)   // nodes per px^2 (scaled by area)
      nodeRadius: 2.2,            // base radius in CSS pixels
      maxLinkDistance: 140,       // max px distance to draw link
      lineWidth: 0.9,
      speed: 0.5,                 // global animation speed multiplier
      repulseRadius: 120,         // pointer repulsion radius
      pointerForce: 0.75,         // how strongly pointer repels nodes
      originAttraction: 0.02,     // spring strength to original position
      friction: 0.92,             // velocity damping
      color1: '#ffffff',         // nodes/lines white         // electric bright
      color2: '#ffffff',          // deeper
      /* very small drift parameters (keeps subtle wandering even without pointer) */
      driftAmplitude: 0.04,
      driftApply: 0.18,
      driftSpeed: 0.0006
    };

    // Respect reduced motion preference
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReduced){
      CONFIG.speed = 0; // freeze animation
    }

    let width = 0, height = 0, nodes = [];
    const pointer = { x: null, y: null, down:false };

    function resize(){
      const rect = canvas.getBoundingClientRect();
      width = Math.max(100, Math.floor(rect.width));
      height = Math.max(80, Math.floor(rect.height));
      canvas.width = Math.floor(width * DPR);
      canvas.height = Math.floor(height * DPR);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // create or prune nodes based on area
      const area = width * height;
      const desired = Math.max(12, Math.round(area * CONFIG.nodeCountDensity));
      if (nodes.length < desired) {
        const toAdd = desired - nodes.length;
        for (let i=0;i<toAdd;i++) nodes.push(createNode());
      } else if (nodes.length > desired) {
        nodes.length = desired;
      }

      // Reassign origin positions to fit new size
      nodes.forEach(n => {
        n.ox = n.oxNormalized * width;
        n.oy = n.oyNormalized * height;
        // if outside new bounds, clamp
        n.x = Math.max(0, Math.min(width, n.x));
        n.y = Math.max(0, Math.min(height, n.y));
      });
    }

    function createNode(){
      // spread origin positions in a subtle grid with jitter
      const ox = Math.random();
      const oy = Math.random();
      const node = {
        oxNormalized: ox, // in [0,1] to allow resize recompute
        oyNormalized: oy,
        ox: ox * width,
        oy: oy * height,
        x: ox * width + (Math.random()-0.5)*30,
        y: oy * height + (Math.random()-0.5)*30,
        vx: (Math.random()-0.5) * 0.6,
        vy: (Math.random()-0.5) * 0.6,
        r: CONFIG.nodeRadius,
        pulse: Math.random()*Math.PI*2,
        hueShift: Math.random()*40 - 20 // slight variance
      };
      return node;
    }

    // Utility: linear interpolation
    function lerp(a,b,t){return a+(b-a)*t}

    // drift internal angle
    let driftAngle = Math.random() * Math.PI * 2;

    // Animation loop
    let last = performance.now();
    function frame(now){
      const dt = Math.min(40, now - last) / 16.666; // ~60fps baseline
      last = now;
      update(dt * CONFIG.speed);
      render();
      if (CONFIG.speed !== 0) requestAnimationFrame(frame);
    }

    function update(elapsed){
      // elapsed may be 0 if reduced motion
      // update global drift angle slowly
      driftAngle += CONFIG.driftSpeed * elapsed;
      const gdX = Math.cos(driftAngle) * CONFIG.driftAmplitude;
      const gdY = Math.sin(driftAngle) * CONFIG.driftAmplitude;

      nodes.forEach(node => {
        // apply the global gentle drift (very small nudge even without pointer)
        node.vx += gdX * CONFIG.driftApply * elapsed;
        node.vy += gdY * CONFIG.driftApply * elapsed;

        // attraction to origin (spring)
        const dx0 = node.ox - node.x;
        const dy0 = node.oy - node.y;
        node.vx += dx0 * CONFIG.originAttraction * elapsed;
        node.vy += dy0 * CONFIG.originAttraction * elapsed;

        // slight procedural motion (per-node subtle wandering)
        node.pulse += 0.01 * elapsed;
        node.vx += Math.cos(node.pulse) * 0.003 * elapsed;
        node.vy += Math.sin(node.pulse) * 0.003 * elapsed;

        // pointer interaction: repulse if within radius
        if (pointer.x !== null){
          const dx = node.x - pointer.x;
          const dy = node.y - pointer.y;
          const dist = Math.hypot(dx,dy);
          if (dist < CONFIG.repulseRadius){
            // normalized force away from pointer
            const force = (1 - (dist / CONFIG.repulseRadius)) * CONFIG.pointerForce * (pointer.down ? 2.2 : 1.0);
            const nx = dx/dist || (Math.random()-0.5);
            const ny = dy/dist || (Math.random()-0.5);
            node.vx += nx * force * elapsed * 1.2;
            node.vy += ny * force * elapsed * 1.2;
          }
        }

        // velocity damping
        node.vx *= CONFIG.friction;
        node.vy *= CONFIG.friction;

        // step
        node.x += node.vx * elapsed;
        node.y += node.vy * elapsed;

        // small bounds clamp with wrap-around-like pull
        if (node.x < -20) node.x = width + 20;
        if (node.x > width + 20) node.x = -20;
        if (node.y < -20) node.y = height + 20;
        if (node.y > height + 20) node.y = -20;
      });
    }

    function render(){
      ctx.clearRect(0,0,width,height);

      // draw links
      ctx.lineWidth = CONFIG.lineWidth;
      ctx.lineCap = 'round';
      for (let i=0;i<nodes.length;i++){
        const a = nodes[i];
        for (let j=i+1;j<nodes.length;j++){
          const b = nodes[j];
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const d2 = dx*dx + dy*dy;
          if (d2 > CONFIG.maxLinkDistance * CONFIG.maxLinkDistance) continue;
          const d = Math.sqrt(d2);
          const t = 1 - (d / CONFIG.maxLinkDistance); // 0..1 (closer => stronger)

          // color gradient based on midpoint + pointer proximity
          const mx = (a.x + b.x) / 2;
          const my = (a.y + b.y) / 2;

          // alpha shaped by distance and by proximity to pointer (highlight)
          let alpha = Math.pow(t, 1.1) * 0.85;
          if (pointer.x !== null){
            const pd = Math.hypot(mx - pointer.x, my - pointer.y);
            if (pd < CONFIG.repulseRadius) alpha = Math.max(alpha, 0.9 * (1 - pd / CONFIG.repulseRadius));
          }

          // gradient stroke
          const grad = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
          grad.addColorStop(0, shadeColor(CONFIG.color1, a.hueShift, alpha));
          grad.addColorStop(1, shadeColor(CONFIG.color2, b.hueShift, alpha));

          ctx.strokeStyle = grad;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }

      // draw nodes
      for (let i=0;i<nodes.length;i++){
        const n = nodes[i];
        // node highlight when pointer near
        let alpha = 0.85;
        if (pointer.x !== null){
          const pd = Math.hypot(n.x - pointer.x, n.y - pointer.y);
          if (pd < CONFIG.repulseRadius) alpha = lerp(1, 0.6, pd / CONFIG.repulseRadius);
        }

        // subtle pulsing radius
        const pulse = 0.6 + Math.sin(n.pulse*1.6) * 0.3;
        const r = Math.max(0.8, n.r * pulse);

        // radial gradient fill for glow
        const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, Math.max(8, r*6));
        g.addColorStop(0, shadeColor(CONFIG.color1, n.hueShift, alpha * 0.95));
        g.addColorStop(0.6, shadeColor(CONFIG.color2, n.hueShift, alpha * 0.25));
        g.addColorStop(1, 'rgba(0,0,0,0)');

        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(n.x, n.y, Math.max(1.4, r*2.6), 0, Math.PI*2);
        ctx.fill();

        // core dot
        ctx.fillStyle = shadeColor('#ffffff', 0, alpha);
        ctx.beginPath();
        ctx.arc(n.x, n.y, Math.max(0.8, r*0.45), 0, Math.PI*2);
        ctx.fill();
      }
    }

    // small helper to apply hue shift + alpha into rgba string
    function shadeColor(hex, hueShift=0, alpha=1){
      // simple hex -> rgb
      const c = hex.replace('#','');
      const r = parseInt(c.substring(0,2),16);
      const g = parseInt(c.substring(2,4),16);
      const b = parseInt(c.substring(4,6),16);
      return `rgba(${r},${g},${b},${Math.max(0,Math.min(1,alpha))})`;
    }

    // pointer handling
    function onPointerMove(e){
      const rect = canvas.getBoundingClientRect();
      const px = (e.clientX - rect.left);
      const py = (e.clientY - rect.top);
      pointer.x = Math.max(0, Math.min(width, px));
      pointer.y = Math.max(0, Math.min(height, py));
    }
    function onPointerLeave(){ pointer.x = null; pointer.y = null; }
    function onPointerDown(){ pointer.down = true; }
    function onPointerUp(){ pointer.down = false; }

    // wire events
    canvas.addEventListener('pointermove', onPointerMove);
    canvas.addEventListener('pointerleave', onPointerLeave);
    canvas.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointerup', onPointerUp);

    // resize observer for responsive canvas
    const ro = new ResizeObserver(resize);
    ro.observe(canvas.parentElement);

    // init nodes and start
    resize();
    // initialize a few steps to settle
    for (let i=0;i<6;i++) update(1);
    if (CONFIG.speed !== 0) requestAnimationFrame(frame); else render();

    // Expose a simple API for debugging from console
    window._graphBg = { nodes, resize, config: CONFIG };

    // --- utility: clamp and lerp defined earlier (redeclare to be safe) ---
    function lerp(a,b,t){return a + (b-a)*t}

  })();
  </script>

 <script>
  (function() {
    const canvas = document.getElementById('hopfieldCanvas');
    if (!canvas) return; // Don't run if the canvas isn't on the page
    const ctx = canvas.getContext('2d');

    let nodes = [];
    let edges = [];
    const numNodes = 30;
    const edgeProbability = 0.1; 

    const colors = {
        background: '#0d1a26',
        edge: 'rgba(128, 128, 128, 0.3)',
        nodeGrey: '#4A5568',
        nodeWhite: '#FFFFFF'
    };
    const nodeRadius = 4;
    const glowColor = 'rgba(255, 255, 255, 0.7)';
    const glowBlur = 12;

    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
    }

    function init() {
        nodes = [];
        edges = [];

        for (let i = 0; i < numNodes; i++) {
            nodes.push({
                id: i,
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 0.3,
                vy: (Math.random() - 0.5) * 0.3,
                radius: nodeRadius,
                isWhite: Math.random() > 0.5,
                flipTimer: Math.random() * 200 + 100,
            });
        }

        for (let i = 0; i < numNodes; i++) {
            for (let j = i + 1; j < numNodes; j++) {
                if (Math.random() < edgeProbability) {
                    edges.push({
                        source: nodes[i],
                        target: nodes[j]
                    });
                }
            }
        }
    }

    function drawEdges() {
        ctx.strokeStyle = colors.edge;
        ctx.lineWidth = 1;
        edges.forEach(edge => {
            ctx.beginPath();
            ctx.moveTo(edge.source.x, edge.source.y);
            ctx.lineTo(edge.target.x, edge.target.y);
            ctx.stroke();
        });
    }

    function drawNodes() {
        nodes.forEach(node => {
            ctx.beginPath();
            if (node.isWhite) {
                ctx.fillStyle = colors.nodeWhite;
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = glowBlur;
            } else {
                ctx.fillStyle = colors.nodeGrey;
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }
            ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
    }

    function update() {
        nodes.forEach(node => {
            node.x += node.vx;
            node.y += node.vy;

            if (node.x - node.radius < 0 || node.x + node.radius > canvas.width) {
                node.vx *= -1;
            }
            if (node.y - node.radius < 0 || node.y + node.radius > canvas.height) {
                node.vy *= -1;
            }
            
            node.flipTimer--;
            if (node.flipTimer <= 0) {
                node.isWhite = !node.isWhite;
                node.flipTimer = Math.random() * 300 + 150;
            }
        });
    }
    
    function animate() {
        ctx.fillStyle = colors.background;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        update();
        drawEdges();
        drawNodes();
        requestAnimationFrame(animate);
    }

    const ro = new ResizeObserver(() => {
        resizeCanvas();
        init();
    });
    ro.observe(canvas);

    resizeCanvas();
    init();
    animate();
  })();
  </script>

  <script>
    (function() {
      const canvas = document.getElementById('lotteryCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      let nodeRadius;
      let verticalSpacing;
      let nodes = [];
      let originalEdges = [];
      let edges = [];

      function init() {
        nodeRadius = canvas.width * 0.025;
        const layers = [
          { nodes: 3, x: canvas.width * 0.2 },
          { nodes: 4, x: canvas.width * 0.45 },
          { nodes: 2, x: canvas.width * 0.7 }
        ];
        let maxNodes = Math.max(...layers.map(l => l.nodes));
        verticalSpacing = canvas.height / (maxNodes + 1);

        nodes = [];
        layers.forEach((layer) => {
          const layerNodes = [];
          const startY = (canvas.height - (layer.nodes - 1) * verticalSpacing) / 2;
          for (let i = 0; i < layer.nodes; i++) {
            const y = startY + i * verticalSpacing;
            layerNodes.push({ x: layer.x, y });
          }
          nodes.push(layerNodes);
        });

        originalEdges = [];
        for (let l = 0; l < layers.length - 1; l++) {
          nodes[l].forEach(fromNode => {
            nodes[l + 1].forEach(toNode => {
              originalEdges.push({ from: fromNode, to: toNode });
            });
          });
        }
        edges = [...originalEdges];
      }

      function drawNodes() {
        nodes.flat().forEach(node => {
          ctx.beginPath();
          ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);
          ctx.fillStyle = '#FFFFFF';
          ctx.fill();
          ctx.strokeStyle = '#CCCCCC';
          ctx.stroke();
        });
      }

      function drawEdges() {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        edges.forEach(edge => {
          ctx.beginPath();
          ctx.moveTo(edge.from.x + nodeRadius, edge.from.y);
          ctx.lineTo(edge.to.x - nodeRadius, edge.to.y);
          ctx.stroke();
        });
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawEdges();
        drawNodes();
      }

      const removalInterval = setInterval(() => {
        if (edges.length === 0) {
          edges = [...originalEdges];
        }
        const randomIndex = Math.floor(Math.random() * edges.length);
        edges.splice(randomIndex, 1);
        redraw();
      }, 500);

      const ro = new ResizeObserver(() => {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        init();
        redraw();
      });
      ro.observe(canvas);

      // Initial setup
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      init();
      redraw();
    })();
  </script>

</body>
</html>
